<?xml version="1.0" encoding="UTF-8"?>
<shaders>
  <shader name="Censored" description="Censors Isaac - demo of using a shader in a limited area">
    <parameters>
      <param name="PlayerPos" type="vec2" studioType="playerpos" />
      <param name="PixelSize" type="float" default="6.0" min="0" max="15" step="0.6" />
      <param name="RegionSize" type="float" default="32.0" min="0" max="200" step="1" />
    </parameters>
    <vertex><![CDATA[
      // Demonstrates applying an effect to a localized area
      
      // Standard Isaac vertex attributes
      attribute vec3 Position;     // Vertex position in 3D space
      attribute vec4 Color;        // Vertex color from game
      attribute vec2 TexCoord;     // UV texture coordinates (0,0 to 1,1)
      attribute vec4 RenderData;   // xy=offset, zw=screen dimensions in pixels
      attribute float Scale;       // Room zoom level
      
      // Custom parameters for the effect
      attribute vec2 PlayerPos;    // Player position in screen pixels
      attribute float PixelSize;   // Size of pixelation blocks (bigger = more censored)
      attribute float RegionSize;  // Size of the censored square in pixels
      
      // Transformation matrix
      uniform mat4 Transform;
      
      // Varyings to pass to fragment shader
      varying vec4 Color0;
      varying vec2 TexCoord0;
      varying vec4 RenderDataOut;
      varying float ScaleOut;
      varying vec2 PlayerPosOut;
      varying float PixelSizeOut;
      varying float RegionSizeOut;
      
      void main(void) {
          // Pass all attributes through to fragment shader
          Color0 = Color;
          TexCoord0 = TexCoord;
          RenderDataOut = RenderData;
          ScaleOut = Scale;
          PlayerPosOut = PlayerPos;
          PixelSizeOut = PixelSize;
          RegionSizeOut = RegionSize;
      
          // Transform vertex position
          gl_Position = Transform * vec4(Position.xyz, 1.0);
      }
    ]]></vertex>
    <fragment><![CDATA[
      // Demonstrates a localized pixelation effect
      //
      // TECHNIQUE:
      // 1. Check if current pixel is within the censored region
      // 2. If inside: apply pixelation by quantizing UV coordinates
      // 3. If outside: render normally
      //
      // PIXELATION EXPLAINED:
      // Pixelation works by making groups of pixels all sample from
      // the same texture coordinate, creating the "blocky" look
      
      // Input varyings from vertex shader
      varying lowp vec4 Color0;           // Vertex color
      varying mediump vec2 TexCoord0;     // UV coordinates (0,0 to 1,1)
      varying lowp vec4 RenderDataOut;    // Screen dimensions in zw
      varying lowp float ScaleOut;        // Room zoom level
      varying mediump vec2 PlayerPosOut;  // Player position in pixels
      varying lowp float PixelSizeOut;    // Pixelation block size
      varying mediump float RegionSizeOut; // Region size in pixels
      
      // Game's rendered frame texture
      uniform sampler2D Texture0;
      
      void main(void) {
          // Convert from screen pixels to normalized UV space (0-1)
          // Scale factor accounts for the room zoom level
          vec2 pos = (PlayerPosOut / RenderDataOut.zw) * ScaleOut;
      
          // Convert pixel-based region size to normalized space
          // Divide by screen width to get UV-space size
          float halfSizeNormalized = (RegionSizeOut * 0.5) / RenderDataOut.z;
      
          // Find the vector from player position to current pixel
          vec2 diff = TexCoord0 - pos;
      
          // Using abs() creates a square region (not circular)
          // abs(diff.x) = distance from center horizontally
          // abs(diff.y) = distance from center vertically
          bool insideRegion = abs(diff.x) <= halfSizeNormalized &&
          abs(diff.y) <= halfSizeNormalized;
      
          if (insideRegion) {
              // This is the core pixelation algorithm:
              //
              // 1. Convert UV to pixel coordinates
              //    UV * screen_size = pixel position
              vec2 pixelCoords = TexCoord0 * RenderDataOut.zw;
      
              // 2. Quantize to grid (floor rounds down to nearest block)
              //    floor(position / blockSize) = which block we're in
              vec2 quantized = floor(pixelCoords / PixelSizeOut);
      
              // 3. Convert back to UV space
              //    block * blockSize / screen_size = UV of block's top-left
              vec2 pixelatedUV = quantized * PixelSizeOut / RenderDataOut.zw;
      
              // Sample texture at the quantized (pixelated) coordinates
              gl_FragColor = Color0 * texture2D(Texture0, pixelatedUV);
          } else {
              // Outside the region, just render the game normally
              gl_FragColor = Color0 * texture2D(Texture0, TexCoord0);
          }
      }
    ]]></fragment>
  </shader>
</shaders>