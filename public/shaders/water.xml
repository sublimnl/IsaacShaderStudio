<?xml version="1.0" encoding="UTF-8"?>
<shaders>
  <!-- Water Shader - Replaces black pixels with a 3D animated ocean surface -->
  <shader name="WaterShader" description="Replaces black pixels with an animated 3D water surface effect">
    <parameters>
      <param name="Time" type="float" studioType="time"/>
      <param name="ScreenSize" type="vec2" default="480,270"/>
      <param name="KeyColor" type="vec3" default="0.0,0.0,0.0"/>
      <param name="KeyThreshold" type="float" default="0.1" min="0.0" max="1.0" step="0.01"/>
      <param name="WaterCol" type="vec3" default="0.0,0.4453,0.7305"/>
      <param name="Water2Col" type="vec3" default="0.0,0.4180,0.6758"/>
      <param name="FoamCol" type="vec3" default="0.8125,0.9609,0.9648"/>
      <param name="FogCol" type="vec3" default="0.6406,0.9453,0.9336"/>
      <param name="SkyCol" type="vec3" default="0.0,0.8203,1.0"/>
      <param name="CameraPos" type="vec3" default="0.0,54.0,11.0"/>
      <param name="CameraRot" type="vec4" default="-0.80,0.0,0.2,1.0"/>
    </parameters>
    <vertex><![CDATA[
      // Water Shader vertex shader for The Binding of Isaac
      // A complex raymarching shader that renders 3D ocean waves
      // Uses chroma keying to replace specific colors (default: black)
      
      // Standard Isaac attributes
      attribute vec3 Position;     // Vertex position in 3D space
      attribute vec4 Color;        // Vertex color from game
      attribute vec2 TexCoord;     // UV texture coordinates (0,0 to 1,1)
      attribute vec4 RenderData;   // xy=offset, zw=screen dimensions
      attribute float Scale;       // Room zoom level
      
      // Animation and rendering parameters
      attribute float Time;        // Auto-incrementing animation timer
      attribute vec2 ScreenSize;   // Screen resolution for raymarching
      
      // Chroma key parameters (for color replacement)
      attribute vec3 KeyColor;     // Color to replace (default black 0,0,0)
      attribute float KeyThreshold; // How close colors must be to match
      
      // Water color customization
      attribute vec3 WaterCol;     // Primary water color (deep blue)
      attribute vec3 Water2Col;    // Secondary water color (lighter blue)
      attribute vec3 FoamCol;      // White foam/highlight color
      attribute vec3 FogCol;       // Distant fog/haze color
      attribute vec3 SkyCol;       // Sky horizon color
      
      // 3D camera parameters
      attribute vec3 CameraPos;    // Virtual camera position (x,y,z)
      attribute vec4 CameraRot;    // Camera rotation as quaternion (x,y,z,w)
      
      // Transformation matrix
      uniform mat4 Transform;
      
      // Varyings to pass to fragment shader
      varying vec4 Color0;
      varying vec2 TexCoord0;
      varying vec4 RenderDataOut;
      varying float ScaleOut;
      
      // Pass all custom parameters to fragment shader
      varying float TimeOut;
      varying vec2 ScreenSizeOut;
      varying vec3 KeyColorOut;
      varying float KeyThresholdOut;
      varying vec3 WaterColOut;
      varying vec3 Water2ColOut;
      varying vec3 FoamColOut;
      varying vec3 FogColOut;
      varying vec3 SkyColOut;
      varying vec3 CameraPosOut;
      varying vec4 CameraRotOut;
      
      void main(void) {
          // Pass all attributes to varyings
          Color0 = Color;
          TexCoord0 = TexCoord;
          RenderDataOut = RenderData;
          ScaleOut = Scale;
          TimeOut = Time;
          ScreenSizeOut = ScreenSize;
          KeyColorOut = KeyColor;
          KeyThresholdOut = KeyThreshold;
          WaterColOut = WaterCol;
          Water2ColOut = Water2Col;
          FoamColOut = FoamCol;
          FogColOut = FogCol;
          SkyColOut = SkyCol;
          CameraPosOut = CameraPos;
          CameraRotOut = CameraRot;
          
          gl_Position = Transform * vec4(Position.xyz, 1.0);
      }
    ]]></vertex>
    <fragment><![CDATA[
      // Water Shader fragment shader for The Binding of Isaac
      // Creates a procedural 3D ocean with animated waves
      // Uses raymarching technique to render a water plane in 3D
      // 
      // TECHNIQUE OVERVIEW:
      // 1. Check if current pixel color matches the key color (chroma key)
      // 2. If it matches, cast a ray from the virtual camera through this pixel
      // 3. Calculate where the ray intersects the water plane (y=0)
      // 4. Use procedural texturing to create animated water appearance
      
      // Input varyings from vertex shader
      varying lowp vec4 Color0;
      varying mediump vec2 TexCoord0;
      varying lowp vec4 RenderDataOut;
      varying lowp float ScaleOut;
      
      // Custom parameter varyings
      varying lowp float TimeOut;
      varying mediump vec2 ScreenSizeOut;
      varying lowp vec3 KeyColorOut;
      varying lowp float KeyThresholdOut;
      varying lowp vec3 WaterColOut;
      varying lowp vec3 Water2ColOut;
      varying lowp vec3 FoamColOut;
      varying lowp vec3 FogColOut;
      varying lowp vec3 SkyColOut;
      varying lowp vec3 CameraPosOut;
      varying lowp vec4 CameraRotOut;
      
      // Game's rendered frame texture
      uniform sampler2D Texture0;
      
      // MATHEMATICAL CONSTANTS
      #define M_2PI 6.283185307   // 2 * PI (full circle in radians)
      #define M_6PI 18.84955592   // 6 * PI (3 full circles)
      
      // ============================================================
      // CIRCLE FUNCTION - Creates soft circular shapes for water caustics
      // ============================================================
      // pos: current position to evaluate
      // c: circle center
      // s: circle size (squared radius)
      // Returns: smooth falloff value for blending
      float circ(vec2 pos, vec2 c, float s) {
          c = abs(pos - c);          // Distance from center
          c = min(c, 1.0 - c);       // Wrap around edges (tiling)
          // smoothstep creates soft edge, -1.0 inverts for blending
          return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;
      }
      
      // ============================================================
      // WATER LAYER FUNCTION - Procedural water caustic pattern
      // ============================================================
      // Creates a complex water caustic pattern using many circles
      // This is a "baked" procedural texture - hand-placed circles
      // for artistic control over the water appearance
      float waterlayer(vec2 uv) {
          uv = mod(uv, 1.0);  // Tile the pattern
          float ret = 1.0;    // Start with full brightness
          
          // Add many overlapping circles to create organic water pattern
          // Each circ() call adds a caustic highlight at a specific position
          ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);
          ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);
          ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);
          ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);
          ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);
          ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);
          ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);
          ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);
          ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);
          ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);
          ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);
          ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);
          ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);
          ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);
          ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);
          ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);
          ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);
          ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);
          ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);
          ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);
          ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);
          ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);
          ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);
          ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);
          ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);
          ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);
          ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);
          ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);
          ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);
          ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);
          ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);
          ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);
          ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);
          ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);
          ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);
          ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);
          ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);
          ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);
          ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);
          ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);
          ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);
          ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);
          ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);
          ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);
          ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);
          ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);
          ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);
          ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);
          ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);
          ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);
          ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);
          ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);
          ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);
          ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);
          ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);
          ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);
          ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);
          ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);
          ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);
          ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);
          ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);
          ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);
          ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);
          ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);
          ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);
          ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);
          ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);
          ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);
          ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);
          ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);
          ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);
          ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);
          ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);
          ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);
          ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);
          return max(ret, 0.0);  // Clamp to positive values
      }
      
      // ============================================================
      // WATER FUNCTION - Creates animated water surface
      // ============================================================
      // uv: world position on water surface
      // cdir: camera direction (for potential reflections)
      vec3 water(vec2 uv, vec3 cdir) {
          uv *= vec2(0.25);  // Scale down for larger wave pattern
          
          // Create two overlapping wave patterns at different speeds
          // d1: slower, larger waves
          // d2: faster, smaller detail waves
          float d1 = mod(uv.x + uv.y, M_2PI);
          float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);
          
          // Animate the waves using Time
          d1 = TimeOut * 0.07 + d1;  // Slow wave animation
          d2 = TimeOut * 0.5 + d2;   // Faster ripple animation
          
          // Calculate wave displacement using sin/cos
          // This creates the organic movement of water
          vec2 dist = vec2(
              sin(d1) * 0.15 + sin(d2) * 0.05,  // X displacement
              cos(d1) * 0.15 + cos(d2) * 0.05   // Y displacement
          );
          
          // Layer water colors using the procedural pattern
          // Mix primary and secondary water colors
          vec3 ret = mix(WaterColOut, Water2ColOut, waterlayer(uv + dist.xy));
          
          // Add foam highlights using inverted/offset pattern
          ret = mix(ret, FoamColOut, waterlayer(vec2(1.0) - uv - dist.yx));
          
          return ret;
      }
      
      // ============================================================
      // PIXTORAY - Convert screen pixel to 3D ray direction
      // ============================================================
      // uv: normalized screen coordinates (0-1)
      // Returns: normalized ray direction in camera space
      vec3 pixtoray(vec2 uv) {
          vec3 pixpos;
          pixpos.xy = uv - 0.5;  // Center the coordinates (-0.5 to 0.5)
          // Correct for aspect ratio so rays aren't distorted
          pixpos.y *= ScreenSizeOut.y / ScreenSizeOut.x;
          pixpos.z = -1.0;       // Ray points into the screen
          return normalize(pixpos);
      }
      
      // ============================================================
      // QUATMUL - Quaternion multiplication for camera rotation
      // ============================================================
      // Quaternions are a way to represent 3D rotations
      // More stable than Euler angles, no gimbal lock
      // q: rotation quaternion (x,y,z,w format)
      // v: vector to rotate
      vec3 quatmul(vec4 q, vec3 v) {
          vec3 qvec = q.xyz;                    // Quaternion's vector part
          vec3 uv = cross(qvec, v);             // First cross product
          vec3 uuv = cross(qvec, uv);           // Second cross product
          uv *= (2.0 * q.w);                    // Scale by quaternion's scalar
          uuv *= 2.0;
          return v + uv + uuv;                  // Combined rotation
      }
      
      // ============================================================
      // MAIN FUNCTION
      // ============================================================
      void main(void) {
          // Sample the original game frame
          vec3 bgColor = texture2D(Texture0, TexCoord0).rgb;
          
          // CHROMA KEY CHECK
          // Calculate how different this pixel is from the key color
          float colorDiff = distance(bgColor, KeyColorOut);
          
          // Only replace pixels that match the key color
          if (colorDiff < KeyThresholdOut) {
              // RAYMARCHING SETUP
              // Convert pixel coordinates to normalized 0-1 range
              vec2 fragCoord = TexCoord0 * ScreenSizeOut;
              vec2 uv = fragCoord.xy / ScreenSizeOut.xy;
              
              // Create ray from camera through this pixel
              vec3 cdir = pixtoray(uv);
              
              // Apply camera rotation using quaternion
              cdir = quatmul(CameraRotOut, cdir);
              
              // RAY-PLANE INTERSECTION
              // Find where the ray hits the water plane (y=0)
              const vec3 ocean = vec3(0.0, 1.0, 0.0);  // Water plane normal
              float dist = -dot(CameraPosOut, ocean) / dot(cdir, ocean);
              vec3 pos = CameraPosOut + dist * cdir;   // Hit position
              
              // RENDER WATER OR SKY
              vec3 pix;
              if (dist > 0.0 && dist < 100.0) {
                  // Ray hits water - render water surface
                  vec3 wat = water(pos.xz, cdir);
                  // Add distance fog for depth
                  pix = mix(wat, FogColOut, min(dist * 0.01, 1.0));
              } else {
                  // Ray misses water - render sky gradient
                  pix = mix(FogColOut, SkyColOut, min(cdir.y * 4.0, 1.0));
              }
              
              gl_FragColor = vec4(pix, 1.0);
          } else {
              // Pixel doesn't match key color - keep original
              gl_FragColor = vec4(bgColor, 1.0);
          }
      }
    ]]></fragment>
  </shader>
</shaders>
