import { useState, useEffect } from 'react'
import { useShaderStore } from '@/site/stores/shaderStore'
import { Download, Settings } from 'lucide-react'
import AceEditor from 'react-ace'
import { formatGLSL } from '@/site/utils/glslFormatter'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/site/components/ui/dialog'
import { Button } from '@/site/components/ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/site/components/ui/tabs'
import { Popover, PopoverContent, PopoverTrigger } from '@/site/components/ui/popover'
import { Switch } from '@/site/components/ui/switch'
import { Label } from '@/site/components/ui/label'

import 'ace-builds/src-noconflict/mode-xml'
import 'ace-builds/src-noconflict/mode-lua'
import 'ace-builds/src-noconflict/theme-tomorrow_night_bright'

type ExportTab = 'metadata' | 'lua' | 'xml'

export function ExportModal() {
  const {
    exportModalOpen,
    setExportModalOpen,
    shaderName,
    shaderDescription,
    vertexCode,
    fragmentCode,
    parameters,
    addConsoleMessage,
  } = useShaderStore()

  const [activeTab, setActiveTab] = useState<ExportTab>('metadata')
  const [metadataContent, setMetadataContent] = useState('')
  const [luaContent, setLuaContent] = useState('')
  const [xmlContent, setXmlContent] = useState('')
  const [stripStudioAttrs, setStripStudioAttrs] = useState(() => {
    try {
      return localStorage.getItem('isaac_shader_studio_strip_attrs') === 'true'
    } catch {
      return false
    }
  })

  // Persist strip setting to localStorage
  useEffect(() => {
    try {
      localStorage.setItem('isaac_shader_studio_strip_attrs', stripStudioAttrs.toString())
    } catch {
      // Ignore storage errors
    }
  }, [stripStudioAttrs])

  // Generate content when modal opens or settings change
  useEffect(() => {
    if (exportModalOpen) {
      setMetadataContent(generateMetadata())
      setLuaContent(generateLua())
      setXmlContent(generateXML(stripStudioAttrs))
    }
  }, [exportModalOpen, shaderName, shaderDescription, vertexCode, fragmentCode, parameters, stripStudioAttrs])

  const generateMetadata = (): string => {
    const name = shaderName || 'MyShader'
    const description = shaderDescription || 'Shader mod generated by Isaac Shader Studio'
    const modName = name.replace(/[^a-zA-Z0-9]/g, '') + 'Mod'
    const directory = modName.toLowerCase()

    // Use CDATA for multiline descriptions
    const isMultiline = description.includes('\n')
    const descriptionContent = isMultiline
      ? `<![CDATA[${description}]]>`
      : description

    return `<?xml version="1.0" encoding="UTF-8"?>
<metadata>
    <name>${modName}</name>
    <directory>${directory}</directory>
    <id></id>
    <description>${descriptionContent}</description>
    <version>1.0</version>
    <visibility>Private</visibility>
</metadata>`
  }

  const generateXML = (stripStudio: boolean = false): string => {
    const name = shaderName || 'MyShader'
    const description = shaderDescription || ''

    // Generate parameters XML
    let paramsXML = ''
    if (parameters.length > 0) {
      paramsXML = '    <parameters>\n'
      parameters.forEach(param => {
        let glslType: string
        let studioType: string | null = null

        if (param.type === 'time') {
          glslType = 'float'
          studioType = 'time'
        } else if (param.type === 'mousepos') {
          glslType = 'vec2'
          studioType = 'mousepos'
        } else if (param.type === 'playerpos') {
          glslType = 'vec2'
          studioType = 'playerpos'
        } else if (param.type === 'tearpos') {
          glslType = 'vec2'
          studioType = 'tearpos'
        } else if (param.type === 'boolean') {
          glslType = 'float'
          studioType = 'boolean'
        } else if (param.type === 'color') {
          glslType = 'vec3'
          studioType = 'color'
        } else {
          glslType = param.type
        }

        let attrs = `name="${param.name}" type="${glslType}"`
        // Studio-specific attributes (only include if not stripping)
        if (!stripStudio) {
          if (studioType) attrs += ` studioType="${studioType}"`
          if (param.default !== undefined) attrs += ` default="${param.default}"`
          if (param.min !== undefined) attrs += ` min="${param.min}"`
          if (param.max !== undefined) attrs += ` max="${param.max}"`
          if (param.step !== undefined) attrs += ` step="${param.step}"`
          if (param.fps !== undefined) attrs += ` fps="${param.fps}"`
          if (param.coordinateSpace) attrs += ` coordinateSpace="${param.coordinateSpace}"`
          if (param.index !== undefined) attrs += ` index="${param.index}"`
        }

        paramsXML += `      <param ${attrs} />\n`
      })
      paramsXML += '    </parameters>\n'
    }

    // Format and indent shader code
    const formattedVertex = formatGLSL(vertexCode)
    const formattedFragment = formatGLSL(fragmentCode)
    const indentedVertex = formattedVertex.split('\n').map(line => '      ' + line).join('\n')
    const indentedFragment = formattedFragment.split('\n').map(line => '      ' + line).join('\n')

    // Build shader tag - description is studio-specific
    const descAttr = (!stripStudio && description) ? ` description="${description}"` : ''

    return `<?xml version="1.0" encoding="UTF-8"?>
<shaders>
  <shader name="${name}"${descAttr}>
${paramsXML}    <vertex><![CDATA[
${indentedVertex}
    ]]></vertex>
    <fragment><![CDATA[
${indentedFragment}
    ]]></fragment>
  </shader>
</shaders>`
  }

  const generateLua = (): string => {
    const name = shaderName || 'MyShader'
    const description = shaderDescription || ''
    const modName = name.replace(/[^a-zA-Z0-9]/g, '') + 'Mod'

    // Get current runtime values for export
    const { runtimeValues } = useShaderStore.getState()

    const formatNumber = (val: number, decimals: number = 3): string => {
      const formatted = val.toFixed(decimals)
      return formatted.replace(/\.?0+$/, '') || '0'
    }

    const paramLines: string[] = []
    const booleanParams: { name: string; defaultEnabled: boolean }[] = []

    parameters.forEach(param => {
      if (param.type === 'time') {
        const fps = param.fps || 60
        if (fps === 60) {
          paramLines.push(`            ${param.name} = Isaac.GetFrameCount()`)
        } else if (fps === 30) {
          paramLines.push(`            ${param.name} = math.floor(Isaac.GetFrameCount() / 2)`)
        } else {
          paramLines.push(`            ${param.name} = math.floor(Isaac.GetFrameCount() * ${fps} / 60)`)
        }
      } else if (param.type === 'playerpos' || param.type === 'mousepos') {
        if (param.type === 'playerpos' && param.coordinateSpace === 'world') {
          paramLines.push(`            ${param.name} = { playerPos.X, playerPos.Y }`)
        } else {
          paramLines.push(`            ${param.name} = { screenPos.X, screenPos.Y }`)
        }
      } else if (param.type === 'tearpos') {
        const tearIndex = param.index || 1
        paramLines.push(`            ${param.name} = tearPositions[${tearIndex}]`)
      } else if (param.type === 'boolean') {
        // Track boolean params so we can create module-level local variables for them
        const currentVal = runtimeValues[param.name] as number | undefined
        const defaultEnabled = currentVal !== undefined ? currentVal !== 0 : (param.default !== '0' && param.default !== '0.0')
        booleanParams.push({ name: param.name, defaultEnabled })
        // Reference the module-level local variable (ShaderName + ParamName), converting boolean to 0.0/1.0
        const localVarName = name.replace(/[^a-zA-Z0-9]/g, '') + param.name
        paramLines.push(`            ${param.name} = ${localVarName} and 1.0 or 0.0`)
      } else if (param.type === 'float') {
        const currentVal = runtimeValues[param.name] as number | undefined
        const val = currentVal !== undefined ? currentVal : parseFloat(param.default || '1.0')
        paramLines.push(`            ${param.name} = ${formatNumber(val)}`)
      } else if (param.type === 'vec2') {
        const currentVal = runtimeValues[param.name] as number[] | undefined
        if (currentVal && Array.isArray(currentVal)) {
          paramLines.push(`            ${param.name} = { ${formatNumber(currentVal[0])}, ${formatNumber(currentVal[1])} }`)
        } else {
          const defaultVal = param.default || '0.0,0.0'
          const parts = defaultVal.split(',').map(v => v.trim())
          paramLines.push(`            ${param.name} = { ${parts[0] || '0.0'}, ${parts[1] || '0.0'} }`)
        }
      } else if (param.type === 'vec3' || param.type === 'color') {
        const currentVal = runtimeValues[param.name] as number[] | undefined
        if (currentVal && Array.isArray(currentVal)) {
          paramLines.push(`            ${param.name} = { ${formatNumber(currentVal[0])}, ${formatNumber(currentVal[1])}, ${formatNumber(currentVal[2])} }`)
        } else {
          const defaultVal = param.default || '0.0,0.0,0.0'
          const parts = defaultVal.split(',').map(v => v.trim())
          paramLines.push(`            ${param.name} = { ${parts[0] || '0.0'}, ${parts[1] || '0.0'}, ${parts[2] || '0.0'} }`)
        }
      } else if (param.type === 'vec4') {
        const currentVal = runtimeValues[param.name] as number[] | undefined
        if (currentVal && Array.isArray(currentVal)) {
          paramLines.push(`            ${param.name} = { ${formatNumber(currentVal[0])}, ${formatNumber(currentVal[1])}, ${formatNumber(currentVal[2])}, ${formatNumber(currentVal[3])} }`)
        } else {
          const defaultVal = param.default || '0.0,0.0,0.0,0.0'
          const parts = defaultVal.split(',').map(v => v.trim())
          paramLines.push(`            ${param.name} = { ${parts[0] || '0.0'}, ${parts[1] || '0.0'}, ${parts[2] || '0.0'}, ${parts[3] || '0.0'} }`)
        }
      }
    })

    const paramsLua = paramLines.length > 0 ? paramLines.join(',\n') : ''

    // Check what coordinate systems we need for playerpos/mousepos parameters
    const needsScreenPos = parameters.some(p =>
      p.type === 'mousepos' || (p.type === 'playerpos' && p.coordinateSpace !== 'world')
    )
    const needsWorldPos = parameters.some(p =>
      p.type === 'playerpos' && p.coordinateSpace === 'world'
    )
    const needsTearPos = parameters.some(p => p.type === 'tearpos')
    const maxTearIndex = parameters
      .filter(p => p.type === 'tearpos')
      .reduce((max, p) => Math.max(max, p.index || 1), 0)
    const needsPlayer = needsScreenPos || needsWorldPos

    // Build the module-level boolean locals (outside the function)
    let moduleLevelLocals = ''
    if (booleanParams.length > 0) {
      for (const boolParam of booleanParams) {
        const localVarName = name.replace(/[^a-zA-Z0-9]/g, '') + boolParam.name
        moduleLevelLocals += `\n-- Set to false to disable`
        moduleLevelLocals += `\nlocal ${localVarName} = ${boolParam.defaultEnabled ? 'true' : 'false'}`
      }
      // Add blank line before the function
      moduleLevelLocals += '\n'
    }

    // Build the function-level locals section
    let localsSection = ''

    if (needsPlayer) {
      localsSection += `
        local player = Isaac.GetPlayer()`
      if (needsWorldPos) {
        localsSection += `
        local playerPos = player.Position`
      }
      if (needsScreenPos) {
        localsSection += `
        local screenPos = Isaac.WorldToScreen(player.Position)`
      }
    }

    // Add tear collection code if needed
    if (needsTearPos) {
      localsSection += `

        -- Collect tear positions (player tears only)
        local tearPositions = {}
        local tears = Isaac.FindByType(EntityType.ENTITY_TEAR, -1, -1, false, false)
        for _, entity in ipairs(tears) do
            if #tearPositions >= ${maxTearIndex} then break end
            local tear = entity:ToTear()
            if tear and tear.SpawnerEntity and tear.SpawnerEntity.Type == EntityType.ENTITY_PLAYER then
                local tearScreenPos = Isaac.WorldToScreen(tear.Position)
                table.insert(tearPositions, { tearScreenPos.X, tearScreenPos.Y + tear.Height })
            end
        end
        -- Pad with zeros for unused slots
        while #tearPositions < ${maxTearIndex} do
            table.insert(tearPositions, { 0, 0 })
        end`
    }

    // Build description comment if present (each line gets its own comment)
    const descriptionComment = description
      ? '\n' + description.split('\n').map(line => `-- ${line}`).join('\n')
      : ''

    return `-- Shader: ${name}${descriptionComment}
-- Generated by Isaac Shader Studio

local ${modName} = RegisterMod("${modName}", 1)
${moduleLevelLocals}
function ${modName}:GetShaderParams(shaderName)
    if shaderName == '${name}' then${localsSection}

        local params = {
${paramsLua}
        }
        return params
    end
end

${modName}:AddCallback(ModCallbacks.MC_GET_SHADER_PARAMS, ${modName}.GetShaderParams)`
  }

  const handleDownload = async () => {
    const name = shaderName || 'MyShader'
    const modName = name.replace(/[^a-zA-Z0-9]/g, '') + 'Mod'

    // Try to use JSZip if available
    if (window.JSZip) {
      const zip = new window.JSZip()
      zip.file('metadata.xml', metadataContent)
      zip.file('main.lua', luaContent)
      zip.folder('content')?.file('shaders.xml', xmlContent)

      const blob = await zip.generateAsync({ type: 'blob' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `${modName}.zip`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      addConsoleMessage('success', `Downloaded mod: ${modName}.zip`)
    } else {
      // Fallback: download individual files
      const downloadFile = (content: string, filename: string) => {
        const blob = new Blob([content], { type: 'text/plain' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = filename
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      }

      downloadFile(metadataContent, 'metadata.xml')
      downloadFile(luaContent, 'main.lua')
      downloadFile(xmlContent, 'shaders.xml')

      addConsoleMessage('success', `Downloaded shader files (JSZip not available for zip archive)`)
    }

    setExportModalOpen(false)
  }

  return (
    <Dialog open={exportModalOpen} onOpenChange={setExportModalOpen}>
      <DialogContent className="max-w-[1000px] h-[80vh] flex flex-col p-0" fullscreenable>
        <DialogHeader className="px-6 pt-6 pb-0">
          <DialogTitle>Export Shader Mod</DialogTitle>
          <DialogDescription className="sr-only">
            Preview and download your shader mod files
          </DialogDescription>
        </DialogHeader>

        <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as ExportTab)} className="flex-1 flex flex-col px-6 overflow-hidden">
          <TabsList className="w-full justify-start">
            <TabsTrigger value="metadata">metadata.xml</TabsTrigger>
            <TabsTrigger value="lua">main.lua</TabsTrigger>
            <TabsTrigger value="xml">content/shaders.xml</TabsTrigger>
          </TabsList>

          <div className="flex-1 border border-border rounded-md overflow-hidden mt-2">
            <TabsContent value="metadata" className="h-full m-0 data-[state=active]:block hidden">
              <AceEditor
                mode="xml"
                theme="tomorrow_night_bright"
                value={metadataContent}
                onChange={setMetadataContent}
                width="100%"
                height="100%"
                fontSize={13}
                showPrintMargin={false}
                setOptions={{ useWorker: false }}
              />
            </TabsContent>
            <TabsContent value="lua" className="h-full m-0 data-[state=active]:block hidden">
              <AceEditor
                mode="lua"
                theme="tomorrow_night_bright"
                value={luaContent}
                onChange={setLuaContent}
                width="100%"
                height="100%"
                fontSize={13}
                showPrintMargin={false}
                setOptions={{ useWorker: false }}
              />
            </TabsContent>
            <TabsContent value="xml" className="h-full m-0 data-[state=active]:block hidden">
              <AceEditor
                mode="xml"
                theme="tomorrow_night_bright"
                value={xmlContent}
                onChange={setXmlContent}
                width="100%"
                height="100%"
                fontSize={13}
                showPrintMargin={false}
                setOptions={{ useWorker: false }}
              />
            </TabsContent>
          </div>
        </Tabs>

        <DialogFooter className="px-6 pb-6 flex justify-between">
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" size="icon">
                <Settings className="w-4 h-4" />
              </Button>
            </PopoverTrigger>
            <PopoverContent align="start" className="w-80">
              <div className="space-y-4">
                <h4 className="font-medium text-sm">Export Settings</h4>
                <div className="flex items-center justify-between">
                  <Label htmlFor="strip-studio" className="text-sm text-muted-foreground pr-4">
                    Strip Shader Studio attributes from XML
                  </Label>
                  <Switch
                    id="strip-studio"
                    checked={stripStudioAttrs}
                    onCheckedChange={setStripStudioAttrs}
                  />
                </div>
                <p className="text-xs text-muted-foreground">
                  Removes Shader Studio attributes: studioType, default, min, max, step, fps, coordinateSpace, index on params, and description on shader tag.
                </p>
              </div>
            </PopoverContent>
          </Popover>
          <Button onClick={handleDownload}>
            <Download className="w-4 h-4" />
            Download Mod (.zip)
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
